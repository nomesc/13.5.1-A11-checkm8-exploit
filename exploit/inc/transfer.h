#include "libusb-1.0/libusb.h"
#include "./inc/usb.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

static inline void async_transfer_callback(struct libusb_transfer *transfer)
{
    printf("[.] Async transfer sent %x bytes\n", transfer->actual_length);
    libusb_free_transfer(transfer);
}

static inline struct libusb_transfer *create_async_control_transfer(libusb_device_handle *device_handle, unsigned char *buffer, int length, unsigned int timeout)
{
    struct libusb_transfer *transfer = libusb_alloc_transfer(0);
    assert(transfer != NULL);

    transfer->dev_handle = device_handle;
    transfer->flags = LIBUSB_TRANSFER_FREE_BUFFER; // because we always malloc our buffer libusb_free_transfer will take care of it as well
    transfer->type = LIBUSB_TRANSFER_TYPE_CONTROL;
    transfer->timeout = timeout;
    transfer->length = length;
    transfer->callback = async_transfer_callback;
    transfer->buffer = buffer;

    return transfer;
}

static inline void transfer(libusb_device_handle *device_handle, bool incomplete, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, uint16_t wLength, unsigned char *data)
{
    struct timespec wait;
    wait.tv_sec = 0;
    wait.tv_nsec = 8;
    nanosleep(&wait, NULL);
    if (incomplete) /* we will send an async request and interrupt it */
    {
        int ret;
        struct libusb_transfer *transfer;
        int buffer_length = sizeof(struct libusb_control_setup) + wLength;
        unsigned char *buffer = malloc(buffer_length);
        struct timespec sleep;

        assert(buffer != NULL);
        (*(struct libusb_control_setup *)buffer).bmRequestType = bmRequestType;
        (*(struct libusb_control_setup *)buffer).bRequest = bRequest;
        (*(struct libusb_control_setup *)buffer).wValue = wValue;
        (*(struct libusb_control_setup *)buffer).wIndex = wIndex;
        (*(struct libusb_control_setup *)buffer).wLength = wLength;

        if (data != NULL)
            memcpy(buffer + sizeof(struct libusb_control_setup), data, wLength);

        transfer = create_async_control_transfer(device_handle, buffer, buffer_length, 0);
        
        ret = libusb_submit_transfer(transfer);
        assert(ret == 0);
        sleep.tv_sec = 0;
        sleep.tv_nsec = 8800;
        nanosleep(&sleep, NULL);
        ret = libusb_cancel_transfer(transfer);
        assert(ret == 0);
    }
    else
    {
        /* a normal asynchronous transfer */
        libusb_control_transfer(device_handle, bmRequestType, bRequest, wValue, wIndex, data, wLength, 100);
    }
}
