#include "utils.h"

extern char name_string;       // "name"
extern char chosen_string;     // "chosen"
extern char memory_map_string; // "memory-map"
extern unsigned char teletext[16][7];

int32_t mem_cmp(void *s1, void *s2, uint32_t size)
{
    for (int i = 0; i < size; i++)
    {
        if (((uint8_t *)s1)[i] != ((uint8_t *)s2)[i])
            return -1;
    }
    return 0;
}

uint32_t compare_sequences(uint32_t *s1, uint32_t *s2, uint32_t number_of_instructions)
{
    while (number_of_instructions != 0)
    {
        if (*s1 != *s2)
            return 0;
        s1++;
        s2++;
        number_of_instructions--;
    }
    return 1;
}

// !!Doar pentru instructiuni(din cauza asumptiilor pe care le-am facut in algoritm)
int32_t patch_finder(uint32_t *image, instruction_patch *patches, const uint32_t number_of_patches)
{
    uint32_t current_patch;
    uint32_t current_instruction;
    uint32_t found = 0;

    for (current_instruction = 0; current_instruction < (0x2600000 / 4); current_instruction++)
    {
        for (current_patch = 0; current_patch < number_of_patches; current_patch++)
        {
            if (patches[current_patch].address == 0)
            {
                if (compare_sequences(image + current_instruction, patches[current_patch].function, patches[current_patch].number_of_instructions) == 1)
                {
                    patches[current_patch].address = image + current_instruction;
                    found++;
                    if (found == number_of_patches)
                        return 0;
                }
            }
        }
    }

    return -1;
}

/*int32_t patch_finder_test(uint32_t *image, instruction_patch *patches, const uint32_t number_of_patches, uint64_t size)
{
    uint32_t current_patch;
    uint32_t current_instruction;
    uint32_t found = 0;

    for (current_instruction = 0; current_instruction < (size / 4); current_instruction++)
    {
        for (current_patch = 0; current_patch < number_of_patches; current_patch++)
        {
            if (patches[current_patch].address == 0)
            {
                if (compare_sequences(image + current_instruction, patches[current_patch].function, patches[current_patch].number_of_instructions) == 1)
                {
                    patches[current_patch].address = image + current_instruction;
                    found++;
                    if (found == number_of_patches)
                        return 0;
                }
            }
        }
    }

    return -1;
}
*/
void apply_pathches(instruction_patch *patches, const uint32_t number_of_patches)
{
    uint32_t i;
    uint32_t j;
    for (i = 0; i < number_of_patches; i++)
    {
        for (j = 0; j < patches[i].number_of_instructions; j++)
            patches[i].address[j] = patches[i].patch[j];
    }
}

void change_apple(Boot_Video Video)
{
    uint64_t x;
    uint64_t y;
    uint32_t *pixels = (uint32_t *)Video.v_baseAddr;
    uint64_t maxX = Video.v_width;
    uint64_t maxY = Video.v_height;
    uint32_t old_background = pixels[0];
    for (x = 0; x < maxX; x++)
        for (y = 0; y < maxY; y++)
        {
            if (pixels[y * (Video.v_rowBytes) / 4 + x] != old_background)
                pixels[y * (Video.v_rowBytes) / 4 + x] = ~0xA8763E;
        }
}

void draw_status(uint64_t *x, uint64_t *y, Boot_Video Video, uint32_t fail)
{
    uint32_t color = 0xA8763E;
    if (fail)
        color = ~color;
    uint32_t *pixels = (uint32_t *)Video.v_baseAddr;
    for (int row = 0; row < 8; row++)
    {
        for (int column = 0; column < 8; column++)
        {
            for (int i = 0; i < 4; i++)
            {
                pixels[0 + 4 * (*y + row) * (Video.v_rowBytes) / 4 + 4 * (*x + column) + i * (Video.v_rowBytes / 4)] = ~color;
                pixels[1 + 4 * (*y + row) * (Video.v_rowBytes) / 4 + 4 * (*x + column) + i * (Video.v_rowBytes / 4)] = ~color;
                pixels[1 + 4 * (*y + row) * (Video.v_rowBytes) / 4 + 4 * (*x + column) + i * (Video.v_rowBytes / 4)] = ~color;
                pixels[3 + 4 * (*y + row) * (Video.v_rowBytes) / 4 + 4 * (*x + column) + i * (Video.v_rowBytes / 4)] = ~color;
            }
        }
    }
    *x += 16;
}

//DEVICE TREE MANIPULATION
/*
devicetree_property *devicetree_find_property(devicetree_node **root, char *name)
{
    uint8_t *p = (uint8_t *)(*root);
    devicetree_property *ret = 0;
    p += sizeof(devicetree_node);
    int name_size;
    for (int i = 0; i < (*root)->n_properties; i++)
    {
        devicetree_property *property = (devicetree_property *)p;
        p += sizeof(devicetree_property);
        name_size = 0;
        while (property->name[name_size] != '\0')
            name_size++;
        if (0 == mem_cmp(property->name, name, name_size + 1))
            ret = property;
        p += (property->size + 0x3) & ~0x3;
    }
    *root = (devicetree_node *)p;
    return ret;
}

devicetree_node *devicetree_find_child(devicetree_node *const root, char *name, uint64_t name_len)
{
    devicetree_node *root_copy = root;
    for (int i = 0; i < root->n_children + 1; i++)
    {
        devicetree_node *ret = root_copy;
        devicetree_property *child_name = devicetree_find_property(&root_copy, &name_string);
        if (mem_cmp(name, child_name->data, name_len) == 0)
            return ret;
    }
    return 0;
}

MemoryMapFileInfo *devicetree_find_memory_range(devicetree_node *root, char *name)
{
    // memory-ranges se afla la chosen/memory-map
    devicetree_node *memory_map = devicetree_find_child(root, &chosen_string, 6);
    if (memory_map == 0)
        return 0;
    memory_map = devicetree_find_child(memory_map, &memory_map_string, 10);
    if (memory_map == 0)
        return 0;
    return (MemoryMapFileInfo *)devicetree_find_property(&memory_map, name);
}
*/
void invert_pixel(uint64_t x, uint64_t y, Boot_Video *video)
{
    x *= 4;
    y *= 4;

    int rowOffset = video->v_rowBytes / 4;

    uint32_t *pixels = (uint32_t *)((uintptr_t)video->v_baseAddr + ((uintptr_t)y * (uintptr_t)video->v_rowBytes) + ((uintptr_t)x * (uintptr_t)4));
    for (int i = 0; i < 4; i++)
    {
        pixels[0 + (i * rowOffset)] = ~pixels[0 + (i * rowOffset)];
        pixels[1 + (i * rowOffset)] = ~pixels[1 + (i * rowOffset)];
        pixels[2 + (i * rowOffset)] = ~pixels[2 + (i * rowOffset)];
        pixels[3 + (i * rowOffset)] = ~pixels[3 + (i * rowOffset)];
    }
}

void draw_char(uint64_t x, uint64_t y, char ch, Boot_Video *video)
{
    for (int row = 0; row < 7; row++)
    {
        for (int column = 0; column < 5; column++)
        {
            if (teletext[ch][row] & (1 << column))
            {
                invert_pixel(x + ((5 - 1) - column), y + row, video);
            }
        }
    }
}

void print_addres(uint64_t ptr, uint64_t *x, uint64_t *y, Boot_Video *video)
{
    for (int i = 7; i >= 0; i--)
    {
        uint8_t cur = (ptr >> (i * 8)) & 0xFF;
        char first = cur >> 4;

        char second = cur & 0xF;

        draw_char(*x, *y, first, video);
        *x += 7;
        draw_char(*x, *y, second, video);
        *x += 7;
    }
    *y += 0x10;
}