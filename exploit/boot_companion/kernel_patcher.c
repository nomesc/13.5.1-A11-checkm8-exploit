#include "utils.h"

extern char new_args;
extern char kernel_version_string; //16
//extern char __TEXT_EXEC_string;
extern char chosen_string;
extern char memory_map_string;
extern char name_string;
extern char debug_enabled_string;

//extern void kernel_rw_hook();
//extern void kernel_rw_hook_end();
extern void rootify_thread_hook();
extern void rootify_proc_hook();

// Instructions
#define mov_x0_1 0xD2800020
#define mov_w0_0 0x52800000
#define nop 0xD503201F
#define cmp_x8_x8 0xEB08011F

// Interesting locations
#define static_vm_entry 0xfffffff008200578ULL//0xfffffff008218578ULL
#define pid_eq_0_branch 0xfffffff00807bbd8ULL//0xfffffff008096f70ULL
#define task_for_pid_posix_check 0xfffffff00807bc00ULL//0xfffffff008096f98ULL
#define mach_proc_check_get_task 0xfffffff00807bc14ULL//0xfffffff008096facULL
#define rootify_thread_hook_entry 0xfffffff00807bcd0ULL//0xfffffff008097068ULL
#define rootify_proc_hook_entry 0xfffffff00807bce8ULL//0xfffffff008097080ULL
#define task_conversion_eval_check1 0xfffffff007c00a28ULL//0xfffffff007c1c9a4ULL
#define task_conversion_eval_check2 0xfffffff007c006a4ULL//0xfffffff007c1c620ULL
#define proc_enforce 0xfffffff0090db948

void kernel_patcher(unsigned char *darwin, boot_args *args)
{
    uint64_t x = 8;
    uint64_t y = 8;
    uint64_t i = 0;
    uint64_t j = 0;
    int32_t rez;
    args->Video.v_display = 0;
    while (args->CommandLine[i] != 0)
        i++;
    while ((&new_args)[j] != '\0')
    {
        args->CommandLine[i] = (&new_args)[j];
        i++;
        j++;
    }
    args->CommandLine[i] = '\0';
    change_apple(args->Video);
    draw_status(&x, &y, args->Video, 0); //1

    uint8_t *dt = args->deviceTreeP - args->virtBase + args->physBase;
    debug_property *debug = 0;
    for (int i = 0; i < args->deviceTreeLength; i++)
    {
        rez = mem_cmp(&debug_enabled_string, dt, 14);
        if (rez == 0)
        {
            debug = (debug_property *)dt;
            break;
        }
        dt += 4;
    }
    if (debug == 0)
        goto fail;
    else
        draw_status(&x, &y, args->Video, 0); //2
    debug->enabled = 1;

    uint64_t slide = 0;
    uint64_t unslid_phys_entry = static_vm_entry - args->virtBase + args->physBase;
    slide = (uint64_t)darwin - unslid_phys_entry;

    uint32_t *first_branch = (uint32_t *)(pid_eq_0_branch - args->virtBase + args->physBase + slide);
    *first_branch = nop;

    uint32_t *posix_check = (uint32_t *)(task_for_pid_posix_check - args->virtBase + args->physBase + slide);
    *posix_check = nop;

    uint32_t *mach_check = (uint32_t *)(mach_proc_check_get_task - args->virtBase + args->physBase + slide);
    *mach_check = mov_w0_0;

    uint32_t *task_conversion_eval_hook1 = (uint32_t *)(task_conversion_eval_check1 - args->virtBase + args->physBase + slide);
    *task_conversion_eval_hook1 = nop;

    uint32_t *task_conversion_eval_hook2 = (uint32_t *)(task_conversion_eval_check2 - args->virtBase + args->physBase + slide);
    *task_conversion_eval_hook2 = cmp_x8_x8;

    uint32_t *proc_enforce_patch = (uint32_t *)(proc_enforce - args->virtBase + args->physBase + slide);
    *proc_enforce_patch = 0;

    /*// task_for_pid hook
    uint32_t *hook = (uint32_t *)(tfp_hook - args->virtBase + args->physBase + slide);
    MemoryMapFileInfo *exec = 0;
    dt = args->deviceTreeP - args->virtBase + args->physBase;
    for (int i = 0; i < args->deviceTreeLength; i++)
    {
        rez = mem_cmp(&__TEXT_EXEC_string, dt, 19);
        if (rez == 0)
        {

            exec = (MemoryMapFileInfo *)dt;
            break;
        }
        dt += 4;
    }
    if (exec == 0)
        goto fail;
    else
        draw_status(&x, &y, args->Video, 0); //4

    uint64_t shellcodeLoc = ((exec->paddr + exec->length) - ((uint64_t)&kernel_rw_hook_end - (uint64_t)&kernel_rw_hook)) & ~0x3ULL; // vom sari aici

    hook[0] = nop;
    hook[1] = ldr_x7_pc_4;
    *(uint64_t *)(hook + 2) = shellcodeLoc - args->physBase + args->virtBase;

    y += 0x10;
    x = 0x10;
    print_addres(exec->paddr, &x, &y, &args->Video);
    y += 0x10;
    x = 0x10;
    print_addres(exec->length, &x, &y, &args->Video);
    y += 0x10;
    x = 0x10;
    print_addres((uint64_t)darwin, &x, &y, &args->Video);

    instruction_patch tfp_patch;
    tfp_patch.address = (uint32_t *)shellcodeLoc;
    tfp_patch.number_of_instructions = ((uint64_t)&kernel_rw_hook_end - (uint64_t)&kernel_rw_hook) >> 2;
    tfp_patch.patch = (uint32_t *)&kernel_rw_hook;
    apply_pathches(&tfp_patch, 1);
    draw_status(&x, &y, args->Video, 0); //5
*/

    //root backdoor
    instruction_patch root_backdoor[2];
    root_backdoor[0].patch = (uint32_t *)&rootify_thread_hook;
    root_backdoor[0].address = (uint32_t *)(rootify_thread_hook_entry - args->virtBase + args->physBase + slide);
    root_backdoor[0].number_of_instructions = 5;

    root_backdoor[1].patch = (uint32_t *)&rootify_proc_hook;
    root_backdoor[1].address = (uint32_t *)(rootify_proc_hook_entry - args->virtBase + args->physBase + slide);
    root_backdoor[1].number_of_instructions = 32;
    apply_pathches(root_backdoor, 2);

    // print_addres slide si adresa virtuala a bazei
    y += 0x10;
    x = 0x10;
    print_addres(slide, &x, &y, &args->Video);
    y += 0x10;
    x = 0x10;
    print_addres(args->virtBase, &x, &y, &args->Video);

    goto exit;
fail:
    draw_status(&x, &y, args->Video, 1);
exit:;
    volatile uint64_t freq = 240000000 * 2; // sleep 2 seconds
    while (freq != 0)
        freq--; // sleep pentru 2 secunde
}
