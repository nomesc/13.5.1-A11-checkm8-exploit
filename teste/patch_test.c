#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/fcntl.h>

uint64_t base = 0x18001c000;

typedef struct
{
    uint32_t *function;
    uint32_t *patch;
    uint32_t *address;
    uint32_t number_of_instructions;
} instruction_patch;

uint32_t compare_sequences(uint32_t *s1, uint32_t *s2, uint32_t number_of_instructions)
{
    while (number_of_instructions != 0)
    {
        if (*s1 != *s2)
            return 0;
        s1++;
        s2++;
        number_of_instructions--;
    }
    return 1;
}

// !!Doar pentru instructiuni(din cauza asumptiilor pe care le-am facut in algoritm)
int32_t patch_finder(uint32_t *image, instruction_patch *patches, const uint32_t number_of_patches)
{
    uint32_t current_patch;
    uint32_t current_instruction;
    uint32_t found = 0;

    for (current_instruction = 0; current_instruction < (0x1C8000 / 4); current_instruction++)
    {
        for (current_patch = 0; current_patch < number_of_patches; current_patch++)
        {
            if (patches[current_patch].address == 0)
            {
                if (compare_sequences(image + current_instruction, patches[current_patch].function, patches[current_patch].number_of_instructions) == 1)
                {
                    patches[current_patch].address = image + current_instruction;
                    found++;
                    if (found == number_of_patches)
                        return 0;
                }
            }
        }
    }

    return -1;
}

void apply_pathches(uint32_t *image, instruction_patch *patches, uint32_t number_of_patches)
{
    uint32_t i;
    instruction_patch patch;
    printf("%llx\n", (uint64_t)image);
    for (i = 0; i < number_of_patches; i++)
    {
        patch = patches[i];
        printf("FOUND: %llx\n", patch.address);
        printf("%llx\n", (uint64_t)((uint64_t)patch.address - (uint64_t)image) + base);
    }
}

uint32_t write_ttbr0[] = {0xd5182000, 0xd5033fdf, 0xd65f03c0};
uint32_t write_sctlr[] = {0xd5181000, 0xd5033f9f, 0xd5033fdf};
uint32_t trampoline_start[] = {0xd5034fdf, 0xaa0003fd, 0xaa0103fc};

int main()
{
    char *iboot_path = "/Users/calin/Documents/repos/llb";
    uint32_t patch = 0x9100C484;
    instruction_patch verbose;
    verbose.address = (uint32_t *)0x180031E14ULL;
    verbose.patch = &patch;
    verbose.number_of_instructions = 1;
    //return;
    instruction_patch iBoot_hooks[4];
    int32_t ret;
    uint64_t companion_pointer = 0x1801E4000;
    uint64_t replace = 0x180000000;

    iBoot_hooks[0].address = 0;
    iBoot_hooks[0].function = (uint32_t *)&companion_pointer;
    iBoot_hooks[0].patch = (uint32_t *)&replace;
    iBoot_hooks[0].number_of_instructions = 2;

    int iBoot_fd = open(iboot_path, O_RDONLY);
    struct stat info;
    fstat(iBoot_fd, &info);
    uint32_t *iBoot = malloc(info.st_size);
    read(iBoot_fd, iBoot, info.st_size);

    ret = patch_finder((uint32_t *)iBoot, iBoot_hooks, 1);
    if (ret != 0)
    {
        puts("NU AM GASIT TOT??");
    }
        
    apply_pathches((uint32_t *)iBoot, iBoot_hooks, 1);
}